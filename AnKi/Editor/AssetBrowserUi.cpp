// Copyright (C) 2009-present, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#include <AnKi/Editor/AssetBrowserUi.h>
#include <AnKi/Resource/ImageResource.h>
#include <AnKi/Util/Filesystem.h>

namespace anki {

static const Char* kDefaultMaterial = R"(<!-- This file is generated by the editor -->
<material shadows="1">
	<shaderProgram name="GBufferGeneric">
		<mutation>
			<mutator name="DIFFUSE_TEX" value="0"/>
			<mutator name="SPECULAR_TEX" value="0"/>
			<mutator name="ROUGHNESS_METALNESS_TEX" value="0"/>
			<mutator name="NORMAL_TEX" value="0"/>
			<mutator name="EMISSIVE_TEX" value="0"/>
			<mutator name="ALPHA_TEST" value="0"/>
		</mutation>
	</shaderProgram>

	<inputs>
		<input name="m_diffuseScale" value="0.5 0.5 0.5 1.000000"/>
		<input name="m_specularScale" value="0.04 0.04 0.04"/>
		<input name="m_roughnessScale" value="1.000000"/>
		<input name="m_metalnessScale" value="0.0"/>
		<input name="m_emissionScale" value="0.0 0.0 0.0"/>
		<input name="m_subsurface" value="0.0"/>
	</inputs>
</material>
)";

static const Char* kDefaultParticles = R"(<!-- This file is generated by the editor -->
<particleEmitter>
	<shaderProgram name="GpuParticlesGass" />

	<particleCount value="10"/>
	<emissionPeriod value="0.05"/>
	<particlesPerEmission value="1"/>

	<inputs>
		<input name="m_minParticleLife" value="1"/>
		<input name="m_maxParticleLife" value="2"/>

		<input name="m_minGravityDirection" value="0 1 0"/>
		<input name="m_maxGravityDirection" value="0 1 0"/>
		<input name="m_minGravityMagnitude" value="0.5"/>
		<input name="m_maxGravityMagnitude" value="0.5"/>

		<input name="m_minInitialSize" value="0.78"/>
		<input name="m_maxInitialSize" value="0.82"/>
		<input name="m_minFinalSize" value="0.4"/>
		<input name="m_maxFinalSize" value="0.5"/>

		<input name="m_minInitialAlpha" value="0.5"/>
		<input name="m_maxInitialAlpha" value="1"/>
		<input name="m_minFinalAlpha" value="0"/>
		<input name="m_maxFinalAlpha" value="0"/>

		<input name="m_minStartingPosition" value="0.04 0.1 -0.04"/>
		<input name="m_maxStartingPosition" value="0.04 0.1 0.04"/>
	</inputs>
</particleEmitter>
)";

enum class AssetFileType : U32
{
	kNone,
	kTexture,
	kMaterial,
	kMesh,
	kLua,
	kParticleEmitter,
	kScene
};

class AssetBrowserUi::AssetFile
{
public:
	String m_filename;
	String m_fullFilepath;
	AssetFileType m_type = AssetFileType::kNone;

	AssetFile() = default;

	AssetFile(const AssetFile&) = delete;

	AssetFile(AssetFile&& b)
	{
		*this = std::move(b);
	}

	AssetFile& operator=(const AssetFile&) = delete;

	AssetFile& operator=(AssetFile&& b)
	{
		m_filename = std::move(b.m_filename);
		m_fullFilepath = std::move(b.m_fullFilepath);
		m_type = b.m_type;
		b.m_type = AssetFileType::kNone;
		return *this;
	}
};

class AssetBrowserUi::AssetDir
{
public:
	String m_dirname;
	String m_fullPath;
	DynamicArray<AssetDir> m_children;
	DynamicArray<AssetFile> m_files;
	U32 m_id = 0;

	AssetDir() = default;

	AssetDir(const AssetDir&) = delete;

	AssetDir(AssetDir&& b)
	{
		*this = std::move(b);
	}

	AssetDir& operator=(const AssetDir&) = delete;

	AssetDir& operator=(AssetDir&& b)
	{
		m_dirname = std::move(b.m_dirname);
		m_fullPath = std::move(b.m_fullPath);
		m_children = std::move(b.m_children);
		m_files = std::move(b.m_files);
		m_id = b.m_id;
		b.m_id = 0;
		return *this;
	}
};

AssetBrowserUi::AssetBrowserUi()
{
	ANKI_CHECKF(ResourceManager::getSingleton().loadResource("EngineAssets/Editor/Material.png", m_materialIcon));
	ANKI_CHECKF(ResourceManager::getSingleton().loadResource("EngineAssets/Editor/Mesh.png", m_meshIcon));
}

AssetBrowserUi::~AssetBrowserUi()
{
}

void AssetBrowserUi::buildAssetStructure(DynamicArray<AssetDir>& dirs)
{
	dirs.destroy();

	U32 id = 0;
	ResourceFilesystem::getSingleton().iterateAllDataPaths([&](CString dataPath) {
		// Create root dir for the data path
		AssetDir& dir = *dirs.emplaceBack();
		dir.m_dirname = dataPath;
		dir.m_fullPath = dataPath;
		dir.m_id = id++;

		ResourceFilesystem::getSingleton().iterateFilenamesInDataPath(dataPath, [&](CString filepath) {
			StringList dirNames;
			dirNames.splitString(filepath, '/');

			// Don't need the file
			const String filename = dirNames.getBack();
			dirNames.popBack();

			// Create the dirs recursively
			AssetDir* crntDir = &dir;
			for(CString dirName : dirNames)
			{
				Bool dirFound = false;
				for(AssetDir& childDir : crntDir->m_children)
				{
					if(childDir.m_dirname == dirName)
					{
						dirFound = true;
						crntDir = &childDir;
						break;
					}
				}

				if(!dirFound)
				{
					AssetDir* newDir = crntDir->m_children.emplaceBack();
					newDir->m_dirname = dirName;
					newDir->m_fullPath = crntDir->m_fullPath + "/" + dirName;
					newDir->m_id = id++;

					crntDir = newDir;
				}
			}

			// Create the file
			const String extension = getFileExtension(filename);
			AssetFileType filetype = AssetFileType::kNone;
			if(extension == "ankitex" || extension == "png")
			{
				filetype = AssetFileType::kTexture;
			}
			else if(extension == "ankimtl")
			{
				filetype = AssetFileType::kMaterial;
			}
			else if(extension == "ankimesh")
			{
				filetype = AssetFileType::kMesh;
			}
			else if(extension == "ankipart")
			{
				filetype = AssetFileType::kParticleEmitter;
			}
			else if(extension == "ankiscene")
			{
				filetype = AssetFileType::kScene;
			}

			if(filetype != AssetFileType::kNone)
			{
				AssetFile* file = crntDir->m_files.emplaceBack();
				file->m_fullFilepath = String(dataPath) + "/" + filepath;
				file->m_filename = filename;
				file->m_type = filetype;
			}

			return FunctorContinue::kContinue;
		});

		return FunctorContinue::kContinue;
	});

	for(AssetDir& dir : dirs)
	{
		sortFilesRecursively(dir);
	}
}

void AssetBrowserUi::sortFilesRecursively(AssetDir& root)
{
	std::sort(root.m_files.getBegin(), root.m_files.getEnd(), [](const AssetFile& a, const AssetFile& b) {
		return a.m_filename < b.m_filename;
	});

	std::sort(root.m_children.getBegin(), root.m_children.getEnd(), [](const AssetDir& a, const AssetDir& b) {
		return a.m_dirname < b.m_dirname;
	});

	for(AssetDir& child : root.m_children)
	{
		sortFilesRecursively(child);
	}
}

void AssetBrowserUi::dirTree(const AssetDir& dir)
{
	ImGui::TableNextRow();
	ImGui::TableNextColumn();

	ImGuiTreeNodeFlags treeFlags = ImGuiTreeNodeFlags_None;
	treeFlags |= ImGuiTreeNodeFlags_OpenOnArrow
				 | ImGuiTreeNodeFlags_OpenOnDoubleClick; // Standard opening mode as we are likely to want to add selection afterwards
	treeFlags |= ImGuiTreeNodeFlags_NavLeftJumpsToParent; // Left arrow support
	treeFlags |= ImGuiTreeNodeFlags_SpanFullWidth; // Span full width for easier mouse reach
	treeFlags |= ImGuiTreeNodeFlags_DrawLinesToNodes; // Always draw hierarchy outlines

	if(m_runCtx.m_selectedDir == &dir)
	{
		treeFlags |= ImGuiTreeNodeFlags_Selected;
	}

	const Bool hasChildren = dir.m_children.getSize();
	if(!hasChildren)
	{
		treeFlags |= ImGuiTreeNodeFlags_Leaf | ImGuiTreeNodeFlags_Bullet;
	}

	ImGui::PushID(dir.m_id);
	const Bool nodeOpen = ImGui::TreeNodeEx("", treeFlags, "%s", dir.m_dirname.cstr());
	ImGui::PopID();
	ImGui::SetItemTooltip("%s", dir.m_dirname.cstr());

	if(ImGui::IsItemFocused())
	{
		m_runCtx.m_selectedDir = &dir;
		m_selectedDirPath = dir.m_fullPath;
	}

	if(nodeOpen)
	{
		for(const AssetDir& p : dir.m_children)
		{
			dirTree(p);
		}

		ImGui::TreePop();
	}
}

void AssetBrowserUi::loadImageToCache(CString fname, ImageResourcePtr& img)
{
	// Try to load first
	ANKI_CHECKF(ResourceManager::getSingleton().loadResource(fname, img));

	// Update the cache
	const U32 crntFrame = ImGui::GetFrameCount();
	Bool entryFound = false;
	DynamicArray<ImageCacheEntry>& cache = m_imageCache;
	for(ImageCacheEntry& entry : cache)
	{
		if(entry.m_image->getUuid() == img->getUuid())
		{
			entry.m_lastSeenInFrame = crntFrame;
			entryFound = true;
			break;
		}
	}

	if(!entryFound)
	{
		cache.emplaceBack(ImageCacheEntry{img, crntFrame});
	}

	// Trym the cache: Try to remove stale entries
	const U32 frameInactivityCount = 60 * 30; // ~30"
	while(true)
	{
		Bool foundStaleEntry = false;
		for(auto it = cache.getBegin(); it != cache.getEnd(); ++it)
		{
			ANKI_ASSERT(crntFrame >= it->m_lastSeenInFrame);
			if(crntFrame - it->m_lastSeenInFrame > frameInactivityCount)
			{
				cache.erase(it);
				foundStaleEntry = true;
				break;
			}
		}

		if(!foundStaleEntry)
		{
			break;
		}
	}
}

void AssetBrowserUi::drawWindow(Vec2 initialPosition, Vec2 initialSize, ImGuiWindowFlags windowFlags)
{
	if(!m_open)
	{
		return;
	}

	if(m_assetPaths.getSize() == 0 || m_refreshAssetsPathsNextTime)
	{
		ANKI_CHECKF(ResourceFilesystem::getSingleton().refreshAll());
		buildAssetStructure(m_assetPaths);
		m_refreshAssetsPathsNextTime = false;
	}

	m_runCtx = {};
	setSelected();

	{
		const Vec2 viewportSize = ImGui::GetMainViewport()->WorkSize;
		const Vec2 initialSize = Vec2(viewportSize.y * 0.75f);
		const Vec2 initialPos = (viewportSize - initialSize) / 2.0f;

		m_imageViewerWindow.drawWindow(initialPos, initialSize, 0);
	}

	{
		const Vec2 viewportSize = ImGui::GetMainViewport()->WorkSize;
		const Vec2 initialSize = Vec2(800.0f, 600.0f);
		const Vec2 initialPos = (viewportSize - initialSize) / 2.0f;

		m_particleEditorWindow.drawWindow(initialPos, initialSize, 0);
	}

	{
		const Vec2 viewportSize = ImGui::GetMainViewport()->WorkSize;
		const Vec2 initialSize = Vec2(800.0f, 600.0f);
		const Vec2 initialPos = (viewportSize - initialSize) / 2.0f;

		m_materialEditorWindow.drawWindow(initialPos, initialSize, 0);
	}

	if(ImGui::GetFrameCount() > 1)
	{
		// Viewport is one frame delay so do that when frame >1
		ImGui::SetNextWindowSize(initialSize, ImGuiCond_FirstUseEver);
		ImGui::SetNextWindowPos(initialPosition, ImGuiCond_FirstUseEver);
	}

	if(ImGui::Begin("Assets", &m_open, windowFlags | ImGuiWindowFlags_MenuBar))
	{
		drawMenu();

		// Left side
		{
			if(ImGui::BeginChild("Left", Vec2(300.0f, -1.0f), ImGuiChildFlags_ResizeX | ImGuiChildFlags_Borders | ImGuiChildFlags_NavFlattened))
			{
				if(ImGui::BeginTable("##bg", 1, ImGuiTableFlags_RowBg))
				{
					for(const AssetDir& p : m_assetPaths)
					{
						dirTree(p);
					}

					ImGui::EndTable();
				}
			}
			ImGui::EndChild();
		} // Left side

		ImGui::SameLine();

		// Right side
		{
			// Use the filter to gather the files
			DynamicArray<const AssetFile*> filteredFiles;
			if(m_runCtx.m_selectedDir)
			{
				for(const AssetFile& f : m_runCtx.m_selectedDir->m_files)
				{
					if(m_fileFilter.PassFilter(f.m_filename.cstr()))
					{
						filteredFiles.emplaceBack(&f);
					}
				}
			}

			if(ImGui::BeginChild("Right", Vec2(-1.0f, -1.0f), 0))
			{
				// Increase/decrease icon size
				{
					ImGui::TextUnformatted("Icon Size");
					ImGui::SameLine();
					ImGui::SetNextItemWidth(64.0f);
					ImGui::SliderInt("##Icon Size", &m_cellSize, 5, 11, "%d", ImGuiSliderFlags_AlwaysClamp);
					ImGui::SameLine();
				}

				// Refresh tree
				if(ImGui::Button(ICON_MDI_REFRESH))
				{
					m_refreshAssetsPathsNextTime = true;
				}
				ImGui::SameLine();

				// Filter
				drawfilteredText(m_fileFilter);

				// Contents
				if(ImGui::BeginChild("RightBottom", Vec2(-1.0f, -1.0f), 0))
				{
					iconsChild(filteredFiles);
				}
				ImGui::EndChild();
			}
			ImGui::EndChild();
		} // Right side
	}
	ImGui::End();

	rightClickMenuDialog();
}

void AssetBrowserUi::iconsChild(ConstWeakArray<const AssetFile*> filteredFiles)
{
	const F32 cellWidth = F32(m_cellSize) * 16;
	const U32 columnCount = U32(ImGui::GetContentRegionAvail().x / cellWidth);
	ImGui::SetNextItemWidth(-1.0f);
	const ImGuiTableFlags flags = ImGuiTableFlags_SizingStretchSame | ImGuiTableFlags_Resizable | ImGuiTableFlags_BordersOuter
								  | ImGuiTableFlags_BordersV | ImGuiTableFlags_ContextMenuInBody;
	if(filteredFiles.getSize() && ImGui::BeginTable("Grid", columnCount, flags))
	{
		const U32 rowCount = (filteredFiles.getSize() + columnCount - 1) / columnCount;

		for(U32 row = 0; row < rowCount; ++row)
		{
			ImGui::TableNextRow();
			for(U32 column = 0; column < columnCount; ++column)
			{
				ImGui::TableNextColumn();

				const U32 idx = row * columnCount + column;
				if(idx < filteredFiles.getSize())
				{
					const AssetFile& file = *filteredFiles[idx];

					ImGui::PushID(idx);
					if(file.m_type == AssetFileType::kMaterial)
					{
						ImTextureID id;
						id.m_texture = &m_materialIcon->getTexture();
						if(ImGui::ImageButton("##", id, Vec2(cellWidth)))
						{
							MaterialResourcePtr rsrc;
							ANKI_CHECKF(ResourceManager::getSingleton().loadResource(file.m_fullFilepath, rsrc));
							m_materialEditorWindow.open(*rsrc);
						}
					}
					else if(file.m_type == AssetFileType::kMesh)
					{
						ImTextureID id;
						id.m_texture = &m_meshIcon->getTexture();
						ImGui::ImageButton("##", id, Vec2(cellWidth));
					}
					else if(file.m_type == AssetFileType::kTexture)
					{
						ImageResourcePtr img;
						loadImageToCache(file.m_fullFilepath, img);
						ImTextureID id;
						id.m_texture = &img->getTexture();
						id.m_textureSubresource = TextureSubresourceDesc::all();
						if(ImGui::ImageButton("##", id, Vec2(cellWidth)))
						{
							m_imageViewerWindow.m_image = img;
							m_imageViewerWindow.m_open = true;
						}
					}
					else if(file.m_type == AssetFileType::kParticleEmitter)
					{
						ImGui::PushFont(nullptr, cellWidth - 1.0f);
						if(ImGui::Button(ICON_MDI_CREATION, Vec2(cellWidth)))
						{
							ParticleEmitterResource2Ptr rsrc;
							ANKI_CHECKF(ResourceManager::getSingleton().loadResource(file.m_fullFilepath, rsrc));
							m_particleEditorWindow.open(*rsrc);
						}
						ImGui::PopFont();
					}
					else if(file.m_type == AssetFileType::kScene)
					{
						ImGui::PushFont(nullptr, cellWidth - 1.0f);
						if(ImGui::Button(ICON_MDI_CURTAINS, Vec2(cellWidth)))
						{
							Scene* scene = nullptr;
							if(SceneGraph::getSingleton().loadScene(file.m_fullFilepath, scene))
							{
								ANKI_LOGE("Failed to load scene: %s", file.m_fullFilepath.cstr());
							}
							else
							{
								SceneGraph::getSingleton().setActiveScene(scene);
							}
						}
						ImGui::PopFont();
					}

					ImGui::PopID();

					// Right click
					if(ImGui::IsMouseReleased(ImGuiMouseButton_Right) && ImGui::IsItemHovered())
					{
						m_selectedFilepath = file.m_fullFilepath;
						m_showRightClickMenuDialog = true;
					}

					if(m_selectedFilepath == file.m_fullFilepath)
					{
						m_runCtx.m_selectedFile = &file;
					}

					ImGui::TextWrapped("%s", file.m_filename.cstr());
					ImGui::SetItemTooltip("%s", file.m_fullFilepath.cstr());
				}
			}
		}

		ImGui::EndTable();
	}
	else
	{
		ImGui::TextUnformatted("Empty");
	}
}

void AssetBrowserUi::rightClickMenuDialog()
{
	if(m_showRightClickMenuDialog)
	{
		ImGui::OpenPopup("Right Click");
		m_showRightClickMenuDialog = false;
	}

	if(ImGui::BeginPopup("Right Click"))
	{
		// Delete file
		if(ImGui::Button(ICON_MDI_DELETE_FOREVER " Delete"))
		{
			if(removeFile(m_selectedFilepath))
			{
				ANKI_LOGE("Failed to remove file: %s", m_selectedFilepath.cstr());
			}

			m_refreshAssetsPathsNextTime = true;
			ImGui::CloseCurrentPopup();
		}

		// Rename file
		Array<Char, kMaxTextInputLen> name;
		strncpy(name.getBegin(), m_runCtx.m_selectedFile->m_filename.cstr(), name.getSize());
		if(ImGui::InputText("Rename", name.getBegin(), name.getSize(), ImGuiInputTextFlags_EnterReturnsTrue))
		{
			CString newName(name.getBegin());
			if(newName.getLength())
			{
				String newFilepath = getParentFilepath(m_runCtx.m_selectedFile->m_fullFilepath);
				newFilepath += "/";
				newFilepath += newName;

				ANKI_LOGV("Will rename %s to %s", m_runCtx.m_selectedFile->m_fullFilepath.cstr(), newFilepath.cstr());
				if(renameFile(m_runCtx.m_selectedFile->m_fullFilepath, newFilepath))
				{
					ANKI_LOGE("Renaming failed");
				}
				else
				{
					m_refreshAssetsPathsNextTime = true;
					m_selectedFilepath = newFilepath;
				}
			}
		}

		ImGui::EndPopup();
	}
	else
	{
		// Diselect the file
		m_selectedFilepath.destroy();
	}
}

void AssetBrowserUi::drawMenu()
{
	if(ImGui::BeginMenuBar())
	{
		ImGui::BeginDisabled(m_runCtx.m_selectedDir == nullptr);

		if(ImGui::BeginMenu(ICON_MDI_PLUS_BOX " New"))
		{
			if(ImGui::MenuItem(ICON_MDI_TEXTURE_BOX " Material"))
			{
				String filepath;
				filepath.sprintf("%s/%04u.NewMaterial.ankimtl", m_runCtx.m_selectedDir->m_fullPath.cstr(), m_newMaterialIndex++);

				File file;
				Error err = file.open(filepath, FileOpenFlag::kWrite);
				if(!err)
				{
					err = file.writeText(kDefaultMaterial);
				}

				if(err)
				{
					ANKI_LOGE("Failed to create new material: %s", filepath.cstr());
				}

				m_refreshAssetsPathsNextTime = true;
			}

			if(ImGui::MenuItem(ICON_MDI_CREATION " Particles"))
			{
				String filepath;
				filepath.sprintf("%s/%04u.NewParticles.ankipart", m_runCtx.m_selectedDir->m_fullPath.cstr(), m_newMaterialIndex++);

				File file;
				Error err = file.open(filepath, FileOpenFlag::kWrite);
				if(!err)
				{
					err = file.writeText(kDefaultParticles);
				}

				if(err)
				{
					ANKI_LOGE("Failed to create new particles: %s", filepath.cstr());
				}

				m_refreshAssetsPathsNextTime = true;
			}

			if(ImGui::MenuItem(ICON_MDI_CURTAINS " Scene"))
			{
				String filepath;
				filepath.sprintf("%s/%04u.NewScene.ankiscene", m_runCtx.m_selectedDir->m_fullPath.cstr(), m_newMaterialIndex++);

				String randomSceneName;
				randomSceneName.sprintf("%u", U32(getRandom() % kMaxU32));
				Scene* tempScene = SceneGraph::getSingleton().newEmptyScene(randomSceneName);
				tempScene->setCanBeSaved(true);

				if(SceneGraph::getSingleton().saveScene(filepath, *tempScene))
				{
					ANKI_LOGE("Failed to create new scene: %s", filepath.cstr());
				}

				SceneGraph::getSingleton().deleteScene(tempScene);

				m_refreshAssetsPathsNextTime = true;
			}

			ImGui::EndMenu();
		}

		ImGui::EndDisabled();

		if(ImGui::BeginMenu(ICON_MDI_IMPORT " Import"))
		{
			// TODO
			ImGui::EndMenu();
		}

		ImGui::EndMenuBar();
	}
}

template<typename TFunc, typename TFunc2>
FunctorContinue AssetBrowserUi::visitTree(AssetDir& dir, TFunc dirFunc, TFunc2 fileFunc)
{
	FunctorContinue cont = FunctorContinue::kContinue;

	cont = dirFunc(dir);

	for(AssetFile& file : dir.m_files)
	{
		cont = fileFunc(file);
		if(cont == FunctorContinue::kStop)
		{
			break;
		}
	}

	if(cont == FunctorContinue::kContinue)
	{
		for(AssetDir& child : dir.m_children)
		{
			cont = visitTree(child, dirFunc, fileFunc);
			if(cont == FunctorContinue::kStop)
			{
				break;
			}
		}
	}

	return cont;
}

void AssetBrowserUi::setSelected()
{
	for(AssetDir& rootDir : m_assetPaths)
	{
		visitTree(
			rootDir,
			[this](AssetDir& dir) {
				if(dir.m_fullPath == m_selectedDirPath)
				{
					m_runCtx.m_selectedDir = &dir;
				}
				return FunctorContinue::kContinue;
			},
			[this](AssetFile& file) {
				if(file.m_fullFilepath == m_selectedFilepath)
				{
					m_runCtx.m_selectedFile = &file;
				}
				return FunctorContinue::kContinue;
			});
	}

	if(m_runCtx.m_selectedDir == nullptr)
	{
		m_selectedDirPath.destroy();
	}

	if(m_runCtx.m_selectedFile == nullptr)
	{
		m_selectedFilepath.destroy();
	}
}

} // end namespace anki
