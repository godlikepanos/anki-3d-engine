// Copyright (C) 2009-present, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// This shader accumulates the lighting for every cluster fraction

#pragma anki mutator ENABLE_SHADOWS 0 1
#pragma anki mutator CLIPMAP_DIFFUSE_INDIRECT 0 1

#pragma anki technique Accumulate comp
#pragma anki technique Debug comp

#include <AnKi/Shaders/Include/MiscRendererTypes.h>
#include <AnKi/Shaders/ClusteredShadingFunctions.hlsl>
#include <AnKi/Shaders/IndirectDiffuseClipmaps.hlsl>
#include <AnKi/Shaders/ImportanceSampling.hlsl>

// ===========================================================================
// Accumulate                                                                =
// ===========================================================================
#if ANKI_TECHNIQUE_Accumulate

constexpr F32 kPhaseFunctionAnisotropy = 0.3;

SamplerState g_linearAnyRepeatSampler : register(s0);
SamplerState g_linearAnyClampSampler : register(s1);
SamplerComparisonState g_linearAnyClampShadowSampler : register(s2);

RWTexture3D<Vec4> g_volume : register(u0);
Texture2D<Vec4> g_noiseTex : register(t0);
Texture3D<Vec4> g_prevVolume : register(t1);

StructuredBuffer<GpuSceneLight> g_lights : register(t2);
Texture2D<Vec4> g_shadowAtlasTex : register(t3);
StructuredBuffer<GpuSceneFogDensityVolume> g_fogDensityVolumes : register(t4);
StructuredBuffer<Cluster> g_clusters : register(t5);
Texture2D g_depthMap : register(t6);
#	if !CLIPMAP_DIFFUSE_INDIRECT
StructuredBuffer<GpuSceneGlobalIlluminationProbe> g_giProbes : register(t7);
#	endif

ConstantBuffer<GlobalRendererConstants> g_globalConstants : register(b0);

ANKI_FAST_CONSTANTS(VolumetricLightingConstants, g_consts)

// https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html
F32 phaseFunction2(Vec3 pont2CameraDir, Vec3 point2LightDir, F32 g)
{
	const F32 g2 = g * g;
	const F32 cosTheta = max(0.0, dot(pont2CameraDir, point2LightDir));
	const F32 cosTheta2 = cosTheta * cosTheta;

	const F32 a = (3.0 * (1.0 - g2)) / (2.0 * (2.0 + g2));
	const F32 b = (1.0 + cosTheta2) / pow(1.0 + g2 - 2.0 * g * cosTheta, 3.0 / 2.0);

	return saturate(a * b);
}

// Found in https://www.shadertoy.com/view/XlBSRz
float phaseFunction(Vec3 pont2CameraDir, Vec3 point2LightDir, F32 g)
{
	return 1.0 / (4.0 * kPi);
}

Vec4 accumulateLightsAndFog(Cluster cluster, Vec3 worldPos, F32 negativeZViewSpace, F32 noise)
{
	ANKI_MAYBE_UNUSED(negativeZViewSpace);

	Vec3 color = 0.0;
	const Vec3 viewDir = normalize(g_globalConstants.m_cameraPosition - worldPos);

	// Dir light
	const DirectionalLight dirLight = g_globalConstants.m_directionalLight;
	if(dirLight.m_active)
	{
		F32 factor = phaseFunction(viewDir, -dirLight.m_direction, kPhaseFunctionAnisotropy);

#	if ENABLE_SHADOWS
		const U32 shadowCascadeCount = dirLight.m_shadowCascadeCount;

		if(shadowCascadeCount > 0u && negativeZViewSpace < dirLight.m_shadowCascadeDistances[shadowCascadeCount - 1u])
		{
			const U32 cascadeIdx = computeShadowCascadeIndex(negativeZViewSpace, dirLight.m_shadowCascadeDistances, shadowCascadeCount);

			factor *= computeShadowFactorDirLight<F32>(dirLight, cascadeIdx, worldPos, g_shadowAtlasTex, g_linearAnyClampShadowSampler);
		}
#	endif

		color += dirLight.m_diffuseColor * factor;
	}

	// Point lights
	U32 idx = 0;
	[loop] while((idx = iteratePointLights(cluster)) != kMaxU32)
	{
		const GpuSceneLight light = g_lights[idx];

		const Vec3 frag2Light = light.m_position - worldPos;
		F32 factor = computeAttenuationFactor<F32>(light.m_radius, frag2Light);

		factor *= phaseFunction(viewDir, normalize(frag2Light), kPhaseFunctionAnisotropy);

#	if ENABLE_SHADOWS
		if(light.m_shadow)
		{
			factor *= computeShadowFactorPointLight<F32>(light, frag2Light, g_shadowAtlasTex, g_linearAnyClampShadowSampler);
		}
#	endif

		color += light.m_diffuseColor * factor;
	}

	// Spot lights
	[loop] while((idx = iterateSpotLights(cluster)) != kMaxU32)
	{
		const GpuSceneLight light = g_lights[idx];

		const Vec3 frag2Light = light.m_position - worldPos;
		F32 factor = computeAttenuationFactor<F32>(light.m_radius, frag2Light);

		const Vec3 l = normalize(frag2Light);

		factor *= computeSpotFactor<F32>(l, light.m_outerCos, light.m_innerCos, light.m_direction);

		factor *= phaseFunction(viewDir, -light.m_direction, kPhaseFunctionAnisotropy);

#	if ENABLE_SHADOWS
		if(light.m_shadow)
		{
			factor *= computeShadowFactorSpotLight<F32>(light, worldPos, g_shadowAtlasTex, g_linearAnyClampShadowSampler);
		}
#	endif

		color += light.m_diffuseColor * factor;
	}

	// Indirect diffuse GI
#	if CLIPMAP_DIFFUSE_INDIRECT
	{
		const SampleClipmapFlag flags = kSampleClipmapFlagNone;
		const Vec3 irradiance = sampleClipmapAvgIrradiance(worldPos, 0.0, g_globalConstants.m_cameraPosition,
														   g_globalConstants.m_indirectDiffuseClipmaps, g_linearAnyRepeatSampler, flags, noise);

		color += irradiance * kPi; // Not sure why the multiplication with Pi but it looks more correct
	}
#	else
	{
		Vec3 diffIndirect = sampleGiProbes<F32>(cluster, g_giProbes, viewDir, worldPos, g_linearAnyClampSampler);
		diffIndirect *= kPi; // Irradiance is pre-divided with PI so fix it

		color += diffIndirect;
	}
#	endif

	// Fog density
	F32 fogDensity = 0.0;
	{
		// Calculate the constant density
		const F32 fogFactor = saturate((worldPos.y - g_consts.m_minHeight) * g_consts.m_oneOverMaxMinusMinHeight);
		fogDensity = lerp(g_consts.m_densityAtMinHeight, g_consts.m_densityAtMaxHeight, fogFactor);

		[loop] while(cluster.m_fogDensityVolumesMask != 0u)
		{
			const U32 idx = U32(firstbitlow2(cluster.m_fogDensityVolumesMask));
			cluster.m_fogDensityVolumesMask &= ~(1u << idx);
			const GpuSceneFogDensityVolume vol = g_fogDensityVolumes[idx];

			F32 factor;
			[branch] if(vol.m_isBox == 1u)
			{
				factor = computeProbeBlendWeight(worldPos, vol.m_aabbMinOrSphereCenter, vol.m_aabbMaxOrSphereRadius, 0.2);
			}
			else
			{
				const Vec3 diff = worldPos - vol.m_aabbMinOrSphereCenter;
				factor = dot(diff, diff) / (vol.m_aabbMaxOrSphereRadius.x * vol.m_aabbMaxOrSphereRadius.x);
				factor = 1.0 - factor;
				factor = max(0.0, factor);
				factor *= factor;
			}

			fogDensity += vol.m_density * factor;
		}
	}

	return Vec4(color, fogDensity);
}

[numthreads(8, 8, 8)] void main(UVec3 svDispatchThreadId : SV_DISPATCHTHREADID)
{
	const UVec3 subClusterId = svDispatchThreadId;
	if(any(subClusterId >= g_consts.m_volumeSize))
	{
		return;
	}

	const ClustererConstants clustererConsts = g_globalConstants.m_clusterer;

	// Find a random pos inside the cluster
#	if 1
	Vec3 randomFactor = TEX(g_noiseTex, subClusterId.xy % 64).rgb;
	randomFactor = animateBlueNoise(randomFactor, g_globalConstants.m_frame + subClusterId.z);
#	else
	const UVec3 seed = rand3DPCG16(UVec3(subClusterId.xy, (g_globalConstants.m_frame + subClusterId.z) % 8u));
	const Vec2 random2 = hammersleyRandom16(g_globalConstants.m_frame % 16, 16, seed);
	Vec3 randomFactor = random2.xyx;
#	endif

	const Vec3 subClusterIdf = subClusterId;
	const Vec3 uvw = (subClusterIdf + randomFactor) / Vec3(g_consts.m_volumeSize);

	// View space
	const F32 negativeZViewSpace = g_consts.m_subZSplitThickness * (subClusterIdf.z + randomFactor.z) + g_globalConstants.m_matrices.m_near;
	const Vec3 viewPos = Vec3(uvToNdc(uvw.xy) * g_globalConstants.m_matrices.m_unprojectionParameters.xy * -negativeZViewSpace, -negativeZViewSpace);

	// Compute depth of sample point
	const Vec4 v4 = mul(g_globalConstants.m_matrices.m_projection, Vec4(viewPos, 1.0));
	const F32 depthSample = v4.z / v4.w;
	const F32 depth = g_depthMap.SampleLevel(g_linearAnyClampSampler, uvw.xy, 0.0).x;

	Bool validSample;
	Vec4 lightAndFog;
	if(depthSample < depth)
	{
		// Valid sample, do lighting

		validSample = true;

		// Get the final world pos
		const Vec3 worldPos = mul(g_globalConstants.m_matrices.m_cameraTransform, Vec4(viewPos, 1.0));

		// Get the cluster
		const UVec3 clusterId = subClusterId >> g_consts.m_clusterSubdivision;
		const U32 tileIdx = clusterId.y * clustererConsts.m_tileCounts.x + clusterId.x;
		Cluster cluster = SBUFF(g_clusters, tileIdx);

		const Cluster split = SBUFF(g_clusters, clustererConsts.m_tileCounts.x * clustererConsts.m_tileCounts.y + clusterId.z);

		cluster = mergeClusters(cluster, split);

		// Do lighting
		lightAndFog = accumulateLightsAndFog(cluster, worldPos, negativeZViewSpace, randomFactor.x);
	}
	else
	{
		// Invalid sample, regect it

		validSample = false;
		lightAndFog = 0.0;
	}

	// Read the prev result
	{
		// Better get a new world pos in the center of the cluster. Using worldPos creates noisy results
		const Vec2 uv = (subClusterIdf.xy + 0.5) / g_consts.m_volumeSize.xy;
		const F32 negativeZViewSpace = g_consts.m_subZSplitThickness * (subClusterIdf.z + 0.5) + g_globalConstants.m_matrices.m_near;
		const Vec3 viewPos = Vec3(uvToNdc(uv) * g_globalConstants.m_matrices.m_unprojectionParameters.xy * -negativeZViewSpace, -negativeZViewSpace);
		const Vec3 midWPos = mul(g_globalConstants.m_matrices.m_cameraTransform, Vec4(viewPos, 1.0));

		// Project
		const Vec4 prevClipPos4 = mul(g_globalConstants.m_previousMatrices.m_viewProjection, Vec4(midWPos, 1.0));
		const Vec3 prevClipPos = prevClipPos4.xyz / prevClipPos4.w;

		// Read prev
		if(all(abs(prevClipPos.xy) <= 1.0) && prevClipPos.z > 0.0)
		{
			Vec3 uvw;
			uvw.xy = ndcToUv(prevClipPos.xy);
			uvw.z = computeVolumeWTexCoord(prevClipPos.z, clustererConsts.m_lightVolumeWMagic.x, clustererConsts.m_lightVolumeWMagic.y);

			const Vec4 history = g_prevVolume.SampleLevel(g_linearAnyClampSampler, uvw, 0.0);
			lightAndFog = lerp(history, lightAndFog, (validSample) ? 1.0 / 16.0 : 0.0);
		}
	}

	// Write result
	TEX(g_volume, subClusterId) = lightAndFog;
}

#endif

// ===========================================================================
// Debug                                                                     =
// ===========================================================================
#if ANKI_TECHNIQUE_Debug

Texture3D g_lightVolume : register(t0);
Texture2D g_depthBuffer : register(t1);

RWTexture2D<Vec4> g_outTex : register(u0);

ConstantBuffer<GlobalRendererConstants> g_consts : register(b0);

SamplerState g_linearAnyClampSampler : register(s0);

[numthreads(8, 8, 1)] void main(COMPUTE_ARGS)
{
	UVec2 outTexSize;
	g_outTex.GetDimensions(outTexSize.x, outTexSize.y);

	const UVec2 coord = svDispatchThreadId.xy;
	if(any(coord >= outTexSize))
	{
		return;
	}

	const F32 depth = TEX(g_depthBuffer, coord).x;

	Vec3 uvw;
	uvw.xy = (coord + 0.5) / outTexSize;
	uvw.z = computeVolumeWTexCoord(depth, g_consts.m_clusterer.m_lightVolumeWMagic.x, g_consts.m_clusterer.m_lightVolumeWMagic.y);

	const Vec3 light = g_lightVolume.SampleLevel(g_linearAnyClampSampler, uvw, 0.0).rgb;

	TEX(g_outTex, coord) = Vec4(light, 0.0);
}
#endif
