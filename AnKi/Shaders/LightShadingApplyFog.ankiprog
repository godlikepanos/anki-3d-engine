// Copyright (C) 2009-present, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki technique vert pixel

#include <AnKi/Shaders/QuadVert.hlsl>

#if ANKI_PIXEL_SHADER
#	include <AnKi/Shaders/Functions.hlsl>
#	include <AnKi/Shaders/ClusteredShadingFunctions.hlsl>
#	include <AnKi/Shaders/Include/MiscRendererTypes.h>
#	include <AnKi/Shaders/ImportanceSampling.hlsl>

SamplerState g_linearAnyClampSampler : register(s0);

Texture2D g_depthRt : register(t0);
Texture3D<Vec4> g_fogVolume : register(t1);

ConstantBuffer<GlobalRendererConstants> g_consts : register(b0);

Vec4 main(VertOut input) : SV_TARGET0
{
	Vec3 texSize;
	g_fogVolume.GetDimensions(texSize.x, texSize.y, texSize.z);
	const Vec3 texelSize = 1.0 / texSize;

	// Random
	const UVec3 seed = rand3DPCG16(UVec3(input.m_svPosition.xy, g_consts.m_frame % 8u));
	const Vec2 random = hammersleyRandom16(g_consts.m_frame % 16, 16, seed);
	const Vec2 urandom = random * 2.0 - 1.0;

	// Compute UV coordinates
	const F32 depth = TEX(g_depthRt, input.m_svPosition.xy).r;
	Vec3 uvw;
	uvw.xy = input.m_uv;
	uvw.xy += texelSize * urandom;
	uvw.z = computeVolumeWTexCoord(depth, g_consts.m_clusterer.m_lightVolumeWMagic.x, g_consts.m_clusterer.m_lightVolumeWMagic.y);
	uvw.z += texelSize / 2.0 * urandom.x;

	// Read the volume
	const Vec4 fogVals = g_fogVolume.SampleLevel(g_linearAnyClampSampler, uvw, 0.0);
	const Vec3 inScattering = fogVals.rgb;
	const F32 transmittance = fogVals.a;

	// Apply the fog
	return Vec4(inScattering, transmittance);
}
#endif // ANKI_PIXEL_SHADER
