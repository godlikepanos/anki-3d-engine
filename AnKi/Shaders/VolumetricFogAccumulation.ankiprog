// Copyright (C) 2009-present, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki technique comp

#include <AnKi/Shaders/Include/MiscRendererTypes.h>
#include <AnKi/Shaders/Common.hlsl>

SamplerState g_linearAnyClampSampler : register(s0);
Texture3D<Vec4> g_lightVolume : register(t0);
RWTexture3D<Vec4> g_fogVolume : register(u0);

ANKI_FAST_CONSTANTS(VolumetricFogConstants, g_consts)

[numthreads(8, 8, 1)] void main(UVec3 svDispatchThreadId : SV_DISPATCHTHREADID)
{
	if(any(svDispatchThreadId.xy >= g_consts.m_volumeSize.xy))
	{
		return;
	}

	const Vec2 uv = (Vec2(svDispatchThreadId.xy) + 0.5) / Vec2(g_consts.m_volumeSize.xy);

	Vec4 colorAndDensityFront = 0.0;
	[loop] for(U32 i = 0u; i < g_consts.m_volumeSize.z; ++i)
	{
		// Read the light value and the fog density from the fog volumes
		Vec4 lightAndFogDensity = TEX(g_lightVolume, UVec3(svDispatchThreadId.xy, i));
		lightAndFogDensity.xyz *= g_consts.m_fogDiffuse / kPi;

		// Scattering & absorption
		const F32 scattering = lightAndFogDensity.w * g_consts.m_fogScatteringCoeff * g_consts.m_zSplitThickness;
		const F32 absorption = lightAndFogDensity.w * g_consts.m_fogAbsorptionCoeff * g_consts.m_zSplitThickness;

		// Integrate
		const Vec4 colorAndDensityBack = Vec4(lightAndFogDensity.xyz * scattering, scattering + absorption);

		const Vec3 l = colorAndDensityFront.rgb + saturate(exp(-colorAndDensityFront.a)) * colorAndDensityBack.rgb;
		colorAndDensityFront = Vec4(l.rgb, colorAndDensityFront.a + colorAndDensityBack.a);

		// Write the value
		const Vec4 valToWrite = Vec4(colorAndDensityFront.rgb, saturate(exp(-colorAndDensityFront.a)));
		TEX(g_fogVolume, UVec3(svDispatchThreadId.xy, i)) = valToWrite;
	}
}
