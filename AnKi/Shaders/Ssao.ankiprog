// Copyright (C) 2009-present, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

// Ground truth ambiend occlusion

#pragma anki 16bit

#pragma anki mutator SPATIAL_DENOISE_SAMPLE_COUNT 3 5 7 9
#pragma anki mutator DENOISING_QUARTER_RESOLUTION 0 1

#pragma anki technique Ssao vert pixel comp mutators
#pragma anki technique SsaoSpatialDenoiseHorizontal vert pixel comp
#pragma anki technique SsaoSpatialDenoiseVertical vert pixel comp
#pragma anki technique SsaoTemporalDenoise vert pixel comp

#include <AnKi/Shaders/QuadVert.hlsl>

// ===========================================================================
// SSAO                                                                      =
// ===========================================================================
#if ANKI_TECHNIQUE_Ssao && (ANKI_COMPUTE_SHADER || ANKI_PIXEL_SHADER)
#	include <AnKi/Shaders/Include/MiscRendererTypes.h>
#	include <AnKi/Shaders/Functions.hlsl>
#	include <AnKi/Shaders/PackFunctions.hlsl>
#	include <AnKi/Shaders/FastMathFunctions.hlsl>
#	include <AnKi/Shaders/ImportanceSampling.hlsl>

Texture2D<Vec4> g_gbufferRt2 : register(t0);
Texture2D<Vec4> g_depthTex : register(t1);

Texture2D<Vec4> g_noiseTex : register(t2);
SamplerState g_trilinearRepeatSampler : register(s0);
SamplerState g_linearAnyClampSampler : register(s1);

#	if ANKI_COMPUTE_SHADER
RWTexture2D<Vec4> g_bentNormalsAndSsaoStorageTex : register(u0);
#	endif

ConstantBuffer<SsaoConstants> g_consts : register(b0);

Vec3 unproject(Vec2 ndc)
{
	const F32 d = g_depthTex.SampleLevel(g_linearAnyClampSampler, ndcToUv(ndc), 0.0).r;
	return cheapPerspectiveUnprojection(g_consts.m_unprojectionParameters, ndc, d);
}

Vec4 project(Vec4 p)
{
	return cheapPerspectiveProjection(g_consts.m_projectionMat00, g_consts.m_projectionMat11, g_consts.m_projectionMat22, g_consts.m_projectionMat23,
									  p);
}

F16 computeFalloff(F16 len)
{
	return sqrt(1.0 - min(1.0, len / F16(g_consts.m_radius)));
}

HVec4 doWork(Vec2 coord)
{
	const Vec2 uv = (coord + 0.5) / g_consts.m_viewportSizef;

	const Vec2 ndc = uvToNdc(uv);
	const F32 depth = g_depthTex.SampleLevel(g_linearAnyClampSampler, uv, 0.0).r;
	const Vec3 Pc = cheapPerspectiveUnprojection(g_consts.m_unprojectionParameters, ndc, depth);
	const HVec3 V = normalize(-Pc); // View vector

	// Get noise
#	if 1
	const HVec2 noise2 = animateBlueNoise(g_noiseTex[UVec2(coord) % 64].xyz, g_consts.m_frameCount).yx;
#	else
	const HVec2 noise2 = spatioTemporalNoise(coord, g_consts.m_frameCount);
#	endif

	// Rand slice direction
	const F16 randAng = noise2.x * kPi;
#	if 0
	const F16 aspect = g_consts.m_viewportSizef.x / g_consts.m_viewportSizef.y;
	const HVec2 dir2d = normalize(Vec2(cos(randAng), sin(randAng)) * Vec2(1.0, aspect));
#	else
	const HVec2 dir2d = Vec2(cos(randAng), sin(randAng));
#	endif

	// Project the view normal to the slice
	const Vec3 worldNormal = unpackNormalFromGBuffer(g_gbufferRt2.SampleLevel(g_linearAnyClampSampler, uv, 0.0));
	const HVec3 viewNormal = mul(g_consts.m_viewMat, Vec4(worldNormal, 0.0));

	const HVec3 directionVec = HVec3(dir2d, 0.0);
	const HVec3 orthoDirectionVec = directionVec - (dot(directionVec, V) * V);
	const HVec3 axisVec = normalize(cross(orthoDirectionVec, V));
	const HVec3 projectedNormalVec = viewNormal - axisVec * dot(viewNormal, axisVec);
	const F16 signNorm = (F32)sign(dot(orthoDirectionVec, projectedNormalVec));
	const F16 projectedNormalVecLength = length(projectedNormalVec);
	const F16 cosNorm = saturate(dot(projectedNormalVec, V) / projectedNormalVecLength);
	const F16 n = -signNorm * fastAcos(cosNorm);

	// Find the projected radius
	const Vec3 sphereLimit = Pc + Vec3(g_consts.m_radius, 0.0, 0.0);
	const Vec4 projSphereLimit = project(Vec4(sphereLimit, 1.0));
	const Vec2 projSphereLimit2 = projSphereLimit.xy / projSphereLimit.w;
	const F16 projRadius = length(projSphereLimit2 - ndc);

	// Compute the inner integral (Slide 54)
	const U32 stepCount = max(1u, g_consts.m_sampleCount / 2u);

	const F16 lowHorizonCos1 = cos(n - kPi / 2.0);
	const F16 lowHorizonCos2 = cos(n + kPi / 2.0);

	F16 cosH1 = lowHorizonCos1;
	F16 cosH2 = lowHorizonCos2;

	for(U32 i = 0u; i < stepCount; ++i)
	{
		const F16 stepBaseNoise = F16(i * stepCount) * 0.6180339887498948482;
		const F16 stepNoise = frac(noise2.y + stepBaseNoise);
		F16 s = (i + stepNoise) / F16(stepCount);
		s *= s;
		const Vec2 sampleOffset = dir2d * projRadius * s;

		// h1
		const Vec3 Ps = unproject(ndc + sampleOffset);
		const Vec3 Ds = Ps - Pc;
		const F16 DsLen = length(Ds);
		cosH1 = max(cosH1, lerp(lowHorizonCos1, dot(V, Ds) / DsLen, computeFalloff(DsLen)));

		// h2
		const Vec3 Pt = unproject(ndc - sampleOffset);
		const Vec3 Dt = Pt - Pc;
		const F16 DtLen = length(Dt);
		cosH2 = max(cosH2, lerp(lowHorizonCos2, dot(V, Dt) / DtLen, computeFalloff(DtLen)));
	}

	// Compute the h1 and h2
	const F16 h1 = n + max(-fastAcos(cosH1) - n, -kPi / 2.0);
	const F16 h2 = n + min(fastAcos(cosH2) - n, kPi / 2.0);

	// Compute the final value (Slide 61)
	F16 Vd = -cos(2.0 * h1 - n) + cos(n) + 2.0 * h1 * sin(n);
	Vd += -cos(2.0 * h2 - n) + cos(n) + 2.0 * h2 * sin(n);
	Vd *= 0.25;
	Vd *= projectedNormalVecLength;

	// Apply power
	Vd = pow(Vd, g_consts.m_ssaoPower);

	// Compute bent normal: see "Algorithm 2 Extension that computes bent normals b."
	const F16 t0 =
		(6.0 * sin(h1 - n) - sin(3.0 * h1 - n) + 6.0 * sin(h2 - n) - sin(3.0 * h2 - n) + 16.0 * sin(n) - 3.0 * (sin(h1 + n) + sin(h2 + n))) / 12.0;
	const F16 t1 = (-cos(3.0 * h1 - n) - cos(3.0 * h2 - n) + 8.0 * cos(n) - 3.0 * (cos(h1 + n) + cos(h2 + n))) / 12.0;
	HVec3 bentNormal = HVec3(-dir2d.x * t0, -dir2d.y * t0, t1);
	bentNormal = normalize(bentNormal);
	bentNormal = mul(g_consts.m_viewToWorldMat, Vec4(bentNormal, 0.0));

	return HVec4(bentNormal, Vd);
}

#	if ANKI_COMPUTE_SHADER
[numthreads(64, 1, 1)] void main(COMPUTE_ARGS)
{
	const Vec2 coord = getOptimalDispatchThreadId8x8Amd(svGroupIndex, svGroupId.xy);
	g_bentNormalsAndSsaoStorageTex[coord] = doWork(coord);
}
#	else
Vec4 main(VertOut input) : SV_TARGET0
{
	const Vec2 coord = floor(input.m_svPosition.xy);
	return doWork(coord);
}
#	endif
#endif

// ===========================================================================
// SSAO temporal denoise                                                     =
// ===========================================================================
#if ANKI_TECHNIQUE_SsaoTemporalDenoise && (ANKI_COMPUTE_SHADER || ANKI_PIXEL_SHADER)
#	include <AnKi/Shaders/Functions.hlsl>
#	include <AnKi/Shaders/TonemappingFunctions.hlsl>
#	include <AnKi/Shaders/TonemappingFunctions.hlsl>
#	include <AnKi/Shaders/Include/MiscRendererTypes.h>

SamplerState g_linearAnyClampSampler : register(s0);

Texture2D<Vec4> g_bentNormalsAndSsaoTex : register(t0);
Texture2D<Vec4> g_historyBentNormalsAndSsaoTex : register(t1);
Texture2D<Vec4> g_motionVectorsTex : register(t2);
Texture2D<Vec4> g_historyLengthTex : register(t3);

ConstantBuffer<GlobalRendererConstants> g_globalRendererConsts : register(b0);

#	if ANKI_COMPUTE_SHADER
RWTexture2D<Vec4> g_bentNormalsAndSsaoStorageTex : register(u0);
#	endif

HVec4 doWork(Vec2 coord)
{
	Vec2 viewport;
	g_bentNormalsAndSsaoTex.GetDimensions(viewport.x, viewport.y);
	const Vec2 uv = (coord + 0.5) / viewport;

	const F16 minBlendFactor = 0.1;
	const F16 maxBlendFactor = 0.9;

	const F16 historyLen = g_historyLengthTex.SampleLevel(g_linearAnyClampSampler, uv, 0.0).x * kMaxHistoryLength;

	F16 blendFactor = min(1.0, historyLen / 1.0);
	blendFactor = lerp(maxBlendFactor, minBlendFactor, blendFactor);

	Vec2 uv2 = uv;
#	if !DENOISING_QUARTER_RESOLUTION
	uv2 /= 2.0;
#	endif
	HVec4 outColor = g_bentNormalsAndSsaoTex.SampleLevel(g_linearAnyClampSampler, uv2, 0.0);

	if(blendFactor > maxBlendFactor * 0.9)
	{
		// Don't accumulate
	}
	else
	{
		const Vec2 mv = g_motionVectorsTex.SampleLevel(g_linearAnyClampSampler, uv, 0.0);
		const Vec2 historyUv =
			uv + mv
			+ (g_globalRendererConsts.m_previousMatrices.m_jitterOffsetNdc - g_globalRendererConsts.m_matrices.m_jitterOffsetNdc) / Vec2(2.0, -2.0);

		const HVec4 history = g_historyBentNormalsAndSsaoTex.SampleLevel(g_linearAnyClampSampler, historyUv, 0.0);

		outColor = lerp(history, outColor, blendFactor);
		outColor.xyz = normalize(outColor.xyz);
	}

	return outColor;
}

#	if ANKI_COMPUTE_SHADER
[numthreads(64, 1, 1)] void main(COMPUTE_ARGS)
{
	const Vec2 coord = getOptimalDispatchThreadId8x8Amd(svGroupIndex, svGroupId.xy);
	g_bentNormalsAndSsaoStorageTex[coord] = doWork(coord);
}
#	else
Vec4 main(VertOut input) : SV_TARGET0
{
	const Vec2 coord = floor(input.m_svPosition.xy);
	return doWork(coord);
}
#	endif
#endif

// ===========================================================================
// SSAO spatial denoise                                                      =
// ===========================================================================
#if(ANKI_TECHNIQUE_SsaoSpatialDenoiseHorizontal || ANKI_TECHNIQUE_SsaoSpatialDenoiseVertical) && (ANKI_COMPUTE_SHADER || ANKI_PIXEL_SHADER)
#	include <AnKi/Shaders/BilateralFilter.hlsl>
#	include <AnKi/Shaders/Include/MiscRendererTypes.h>
#	include <AnKi/Shaders/Functions.hlsl>
#	include <AnKi/Shaders/BilateralFilter.hlsl>

SamplerState g_linearAnyClampSampler : register(s0);
Texture2D<Vec4> g_bentNormalsAndSsaoTex : register(t0);
Texture2D<Vec4> g_depthTex : register(t1);

#	if ANKI_COMPUTE_SHADER
RWTexture2D<Vec4> g_bentNormalsAndSsaoStorageTex : register(u0);
#	endif

F32 depthWeight(F32 refDepth, F32 sampleDepth)
{
	return calculateBilateralWeightDepth<F32>(refDepth, sampleDepth, 1.0);
}

HVec4 doWork(Vec2 coord, Bool horizontal)
{
	Vec2 viewport;
	g_bentNormalsAndSsaoTex.GetDimensions(viewport.x, viewport.y);

	// Sample ref
	const F32 refDepth = g_depthTex[coord].x;
	if(refDepth == 1.0)
	{
		return 0.0;
	}

	F32 weightSum = depthWeight(0.0, 0.0); // Highest weight that this function can give

	HVec4 bentNormalAndSsao = g_bentNormalsAndSsaoTex[coord];
	bentNormalAndSsao *= weightSum;

	const F32 halfSampleCount = SPATIAL_DENOISE_SAMPLE_COUNT / 2;
	for(F32 i = -halfSampleCount; i <= halfSampleCount; i += 1.0)
	{
		if(i == 0.0)
		{
			continue;
		}

		Vec2 newCoord = coord + ((horizontal) ? Vec2(i, 0.0) : Vec2(0.0, i));
		newCoord = clamp(newCoord, 0.0, viewport - 1.0);

		const HVec4 sampleColor = g_bentNormalsAndSsaoTex[newCoord];
		const F32 sampleDepth = g_depthTex[newCoord].x;

		const F32 weight = depthWeight(refDepth, sampleDepth);

		bentNormalAndSsao += sampleColor * weight;
		weightSum += weight;
	}

	bentNormalAndSsao /= weightSum;

	bentNormalAndSsao.w = saturate(bentNormalAndSsao.w);
	bentNormalAndSsao.xyz = normalize(bentNormalAndSsao.xyz);

	return bentNormalAndSsao;
}

#	if ANKI_COMPUTE_SHADER
[numthreads(64, 1, 1)] void main(COMPUTE_ARGS)
{
	const Vec2 coord = getOptimalDispatchThreadId8x8Amd(svGroupIndex, svGroupId.xy);
	g_bentNormalsAndSsaoStorageTex[coord] = doWork(coord, ANKI_TECHNIQUE_SsaoSpatialDenoiseHorizontal);
}
#	else
Vec4 main(VertOut input) : SV_TARGET0
{
	const Vec2 coord = floor(input.m_svPosition.xy);
	return doWork(coord, ANKI_TECHNIQUE_SsaoSpatialDenoiseHorizontal);
}
#	endif
#endif
