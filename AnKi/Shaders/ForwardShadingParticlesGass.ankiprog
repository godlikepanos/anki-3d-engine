// Copyright (C) 2009-present, Panagiotis Christopoulos Charitos and contributors.
// All rights reserved.
// Code licensed under the BSD License.
// http://www.anki3d.org/LICENSE

#pragma anki 16bit

#pragma anki mutator ANIMATED_TEXTURE 0 1
#pragma anki mutator LIGHT 0 1

#pragma anki technique ForwardLegacy vert pixel

#include <AnKi/Shaders/ForwardShadingCommon.hlsl>

struct VertIn
{
	U32 m_svVertexId : SV_VERTEXID;
	U32 m_svInstanceId : SV_INSTANCEID;
};

struct VertOut
{
	nointerpolation U32 m_constantsOffset : UNIS_OFFSET;
	nointerpolation F32 m_alpha : ALPHA;
	Vec2 m_uv : TEXCOORD;
	Vec3 m_worldPos : WORLD_POS;
	Vec4 m_svPosition : SV_POSITION;
};

#pragma anki struct AnKiLocalConstants
#pragma anki member F32 m_textureAnimationPeriod 0.0
#pragma anki member Vec4 m_colorScale 1.0 1.0 1.0 1.0
#pragma anki member Vec4 m_colorBias 0.0 0.0 0.0 0.0
#pragma anki member U32 m_diffuseTex 0
#pragma anki struct_end

#if ANKI_VERTEX_SHADER
VertOut main(VertIn input)
{
	const GpuScenePerDraw instance = getGpuScenePerDraw();
	const GpuSceneParticleEmitter2 particles = SBUFF(g_particleEmitters2, instance.m_particleEmitterIndex);
	const GpuSceneMeshLod meshLod = SBUFF(g_meshLods, instance.m_meshLodIndex);

	const U32 particleId = input.m_svInstanceId;

	U32 offset = particles.m_particleStateSteamOffsets[(U32)ParticleProperty::kPosition] + particleId * sizeof(Vec3);
	const Vec3 particlePos = BAB_LOAD(g_gpuScene, Vec3, offset);

	offset = particles.m_particleStateSteamOffsets[(U32)ParticleProperty::kScale] + particleId * sizeof(Vec3);
	const F32 particleScale = BAB_LOAD(g_gpuScene, Vec3, offset).x;

	offset = particles.m_particleStateSteamOffsets[(U32)ParticleProperty::kUserDefined1] + particleId * sizeof(Vec4);
	const F32 particleAlpha = BAB_LOAD(g_gpuScene, Vec4, offset).z;

	VertOut output;

	output.m_uv = g_unifiedGeom_R32G32_Sfloat[meshLod.m_vertexOffsets[(U32)VertexStreamId::kUv] + input.m_svVertexId];

	const Vec3 localPos =
		g_unifiedGeom_R16G16B16A16_Unorm[meshLod.m_vertexOffsets[(U32)VertexStreamId::kPosition] + input.m_svVertexId] * meshLod.m_positionScale
		+ meshLod.m_positionTranslation;

	// Apply the particle scale, rotate the mesh to face the camera (billboard) and finally apply the particle position
	output.m_worldPos = mul(g_globalConstants.m_cameraTransform, Vec4(localPos * particleScale, 0.0)) + particlePos;

	output.m_svPosition = mul(g_globalConstants.m_viewProjectionMatrix, Vec4(output.m_worldPos, 1.0));

	output.m_alpha = particleAlpha;
	output.m_constantsOffset = instance.m_constantsOffset;

	return output;
}
#endif // ANKI_VERTEX_SHADER

#if ANKI_PIXEL_SHADER
PixelOut main(VertOut input)
{
	PixelOut output = (PixelOut)0;
	const AnKiLocalConstants localConstants = loadAnKiLocalConstants(g_gpuScene, WaveReadLaneFirst(input.m_constantsOffset));

#	if ANIMATED_TEXTURE == 1
	Vec4 texCol = readAnimatedTextureRgba(getBindlessTexture2DArrayVec4(localConstants.m_diffuseTex), g_globalSampler,
										  localConstants.m_textureAnimationPeriod, input.m_uv, g_globalRendererConstants.m_time);
#	else
	Vec4 texCol = getBindlessTexture2DVec4(localConstants.m_diffuseTex).Sample(g_globalSampler, input.m_uv);
#	endif

#	if LIGHT
	texCol.rgb = computeLightColorLow(texCol.rgb, input.m_worldPos, input.m_svPosition);
#	endif

	Vec4 colScale = localConstants.m_colorScale;
	colScale.a *= input.m_alpha;
	particleAlpha(texCol, colScale, localConstants.m_colorBias, output);

	return output;
}
#endif // ANKI_PIXEL_SHADER
